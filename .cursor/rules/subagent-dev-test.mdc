---
description: Sub-agente DEV-TEST - Especialista em testes automatizados
globs: 
alwaysApply: false
---

# Sub-agente DEV-TEST

## Especialização
Criação e manutenção de testes automatizados: unitários, integração, e2e.

## Responsabilidades
- Escrever testes unitários
- Criar testes de integração
- Configurar mocks e fixtures
- Garantir cobertura adequada
- Implementar testes e2e
- Manter qualidade dos testes

## Stack Técnico Comum

### JavaScript/TypeScript
- Jest, Vitest
- React Testing Library
- Playwright, Cypress (e2e)
- MSW (Mock Service Worker)

### Python
- pytest
- unittest
- pytest-cov
- factory_boy

### Go
- testing package
- testify
- gomock

## Padrões de Teste

### Teste Unitário - Backend
```typescript
// user.service.test.ts
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { UserService } from './user.service';
import { UserRepository } from './user.repository';
import { EmailService } from '../email/email.service';

// Mocks
vi.mock('./user.repository');
vi.mock('../email/email.service');

describe('UserService', () => {
  let userService: UserService;
  let userRepository: jest.Mocked<UserRepository>;
  let emailService: jest.Mocked<EmailService>;

  beforeEach(() => {
    userRepository = new UserRepository() as jest.Mocked<UserRepository>;
    emailService = new EmailService() as jest.Mocked<EmailService>;
    userService = new UserService(userRepository, emailService);
    
    // Reset mocks
    vi.clearAllMocks();
  });

  describe('create', () => {
    const validUserData = {
      email: 'test@example.com',
      name: 'Test User',
      password: 'password123',
    };

    it('should create a user successfully', async () => {
      // Arrange
      userRepository.findByEmail.mockResolvedValue(null);
      userRepository.create.mockResolvedValue({
        id: '1',
        ...validUserData,
        createdAt: new Date(),
      });
      emailService.sendWelcome.mockResolvedValue(undefined);

      // Act
      const result = await userService.create(validUserData);

      // Assert
      expect(result).toMatchObject({
        id: '1',
        email: validUserData.email,
        name: validUserData.name,
      });
      expect(userRepository.create).toHaveBeenCalledTimes(1);
      expect(emailService.sendWelcome).toHaveBeenCalledWith(validUserData.email);
    });

    it('should throw ConflictError if email already exists', async () => {
      // Arrange
      userRepository.findByEmail.mockResolvedValue({ id: '1', ...validUserData });

      // Act & Assert
      await expect(userService.create(validUserData))
        .rejects
        .toThrow('Email already registered');
      expect(userRepository.create).not.toHaveBeenCalled();
    });

    it('should hash password before saving', async () => {
      // Arrange
      userRepository.findByEmail.mockResolvedValue(null);
      userRepository.create.mockResolvedValue({ id: '1', ...validUserData });

      // Act
      await userService.create(validUserData);

      // Assert
      expect(userRepository.create).toHaveBeenCalledWith(
        expect.objectContaining({
          password: expect.not.stringMatching(validUserData.password),
        })
      );
    });
  });
});
```

### Teste Unitário - Frontend
```tsx
// UserForm.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, vi } from 'vitest';
import { UserForm } from './UserForm';

describe('UserForm', () => {
  const mockOnSubmit = vi.fn();

  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should render all form fields', () => {
    render(<UserForm onSubmit={mockOnSubmit} />);

    expect(screen.getByLabelText(/email/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/name/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/password/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /submit/i })).toBeInTheDocument();
  });

  it('should show validation errors for empty fields', async () => {
    render(<UserForm onSubmit={mockOnSubmit} />);

    // Submit empty form
    fireEvent.click(screen.getByRole('button', { name: /submit/i }));

    // Check for error messages
    await waitFor(() => {
      expect(screen.getByText(/email is required/i)).toBeInTheDocument();
      expect(screen.getByText(/name is required/i)).toBeInTheDocument();
    });

    expect(mockOnSubmit).not.toHaveBeenCalled();
  });

  it('should submit form with valid data', async () => {
    const user = userEvent.setup();
    render(<UserForm onSubmit={mockOnSubmit} />);

    // Fill form
    await user.type(screen.getByLabelText(/email/i), 'test@example.com');
    await user.type(screen.getByLabelText(/name/i), 'Test User');
    await user.type(screen.getByLabelText(/password/i), 'password123');

    // Submit
    await user.click(screen.getByRole('button', { name: /submit/i }));

    // Assert
    await waitFor(() => {
      expect(mockOnSubmit).toHaveBeenCalledWith({
        email: 'test@example.com',
        name: 'Test User',
        password: 'password123',
      });
    });
  });

  it('should disable submit button while loading', () => {
    render(<UserForm onSubmit={mockOnSubmit} isLoading />);

    const submitButton = screen.getByRole('button', { name: /submit/i });
    expect(submitButton).toBeDisabled();
  });
});
```

### Teste de Integração
```typescript
// users.integration.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import { app } from '../app';
import { prisma } from '../lib/prisma';

describe('Users API Integration', () => {
  beforeAll(async () => {
    // Setup test database
    await prisma.$connect();
  });

  afterAll(async () => {
    // Cleanup
    await prisma.user.deleteMany();
    await prisma.$disconnect();
  });

  describe('POST /api/users', () => {
    it('should create a new user', async () => {
      const response = await request(app)
        .post('/api/users')
        .send({
          email: 'integration@test.com',
          name: 'Integration Test',
          password: 'password123',
        })
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        data: {
          email: 'integration@test.com',
          name: 'Integration Test',
        },
      });

      // Verify in database
      const user = await prisma.user.findUnique({
        where: { email: 'integration@test.com' },
      });
      expect(user).not.toBeNull();
    });

    it('should return 400 for invalid data', async () => {
      const response = await request(app)
        .post('/api/users')
        .send({
          email: 'invalid-email',
          name: '',
        })
        .expect(400);

      expect(response.body.success).toBe(false);
      expect(response.body.error).toBe('Validation error');
    });
  });
});
```

## Checklist de Testes

### Para cada função/método
- [ ] Caso de sucesso (happy path)
- [ ] Casos de erro esperados
- [ ] Edge cases (valores limite)
- [ ] Inputs inválidos

### Para cada componente
- [ ] Renderização inicial
- [ ] Interações do usuário
- [ ] Estados (loading, error, empty)
- [ ] Acessibilidade básica

### Para cada endpoint
- [ ] Request válido
- [ ] Validação de input
- [ ] Autenticação/autorização
- [ ] Erros esperados

## Estrutura de Arquivos

```
tests/
├── unit/
│   ├── services/
│   ├── utils/
│   └── components/
├── integration/
│   ├── api/
│   └── database/
├── e2e/
│   └── flows/
├── fixtures/
│   └── users.ts
├── mocks/
│   └── handlers.ts
└── setup.ts
```

## Mocking com MSW

```typescript
// mocks/handlers.ts
import { rest } from 'msw';

export const handlers = [
  rest.get('/api/users', (req, res, ctx) => {
    return res(
      ctx.status(200),
      ctx.json({
        success: true,
        data: [
          { id: '1', email: 'user1@test.com', name: 'User 1' },
          { id: '2', email: 'user2@test.com', name: 'User 2' },
        ],
      })
    );
  }),

  rest.post('/api/users', async (req, res, ctx) => {
    const body = await req.json();
    return res(
      ctx.status(201),
      ctx.json({
        success: true,
        data: { id: '3', ...body },
      })
    );
  }),
];
```

## Output Esperado

```markdown
### Testes - {descrição}

**Arquivos criados:**
- `tests/unit/services/user.service.test.ts` - 5 testes
- `tests/unit/components/UserForm.test.tsx` - 4 testes
- `tests/integration/api/users.test.ts` - 3 testes

**Cobertura:**
| Arquivo | Statements | Branches | Functions |
|---------|------------|----------|-----------|
| user.service.ts | 95% | 90% | 100% |
| UserForm.tsx | 88% | 85% | 100% |

**Mocks criados:**
- `UserRepository` mock
- MSW handlers para `/api/users`

**Fixtures:**
- `validUser` - Dados de usuário válido
- `invalidUser` - Dados para testes de erro
```

## Integração
- **Chamado por:** Agente EXECUTION
- **Colabora com:** dev-backend, dev-frontend
